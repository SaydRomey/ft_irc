
*.tpp files:
	function definitions of template classes
	that were declared in a .hpp header file
Usage:
	Include at the end of the .hpp file with an #include "ClassName.tpp" directive.

*.ipp files: (Often used in the same way as .tpp)
	sometimes might be used for inline functions
	or specialized template implementations, emphasizing implementation details.
Usage:
	Also included at the end of the .hpp file,
	but they can sometimes separate inline code that’s
	specific to certain template instantiations.

*****

Understand the IRC Protocol Basics

Since you're developing an IRC server,
familiarize yourself with the basics of the IRC protocol.
RFC 1459 and RFC 2812 outline the core specifications of the IRC protocol.

Focus on core commands (like NICK, USER, JOIN, PART, PRIVMSG, QUIT)
and how the server should respond.


Implement the Server's Basic Socket Setup

Start by implementing the core functionality
that allows your server to accept incoming connections on a specified port.
Use socket programming basics in C++ to:
	Create a listening socket.
	Accept connections from clients.
	Handle basic data reception and transmission.


Create a Basic Client Handler

After setting up the server socket, work on handling multiple clients.
Initially, you can use a simple array or vector to manage connections,
and later you can expand to handle them more dynamically.
Use select or poll to manage multiple connections simultaneously,
which is crucial for real-time communication like IRC.

Plan the Main Project Loop and Command Parsing
Implement a basic loop to:
	Listen for incoming commands from clients.
	Parse these commands according to IRC specifications.
	Start with simple commands like NICK and USER,
		which establish a user’s presence on the server.


Plan the Main Project Loop and Command Parsing

Implement a basic loop to:
Listen for incoming commands from clients.
Parse these commands according to IRC specifications.
Start with simple commands like NICK and USER,
which establish a user’s presence on the server.

*****

Dividing the workload:

1. Networking and Connection Management

Team Member A could focus on setting up the core networking functionalities.

Responsibilities include:
Initializing the server socket, accepting connections, and managing multiple clients.
Implementing select or poll for handling multiple connections efficiently.
Creating a way to handle disconnections gracefully.

This person would also set up the basic loop that listens for commands,
passing them on to be parsed.


2. Command Parsing and Handling

Team Member B could be responsible for parsing commands and implementing their logic.

Responsibilities include:
Creating a command parser that reads and identifies incoming commands from clients.
Implementing core IRC commands: NICK, USER, JOIN, PART, PRIVMSG, QUIT, etc.
Building error handling and response messages according to the IRC protocol.
This role will need close collaboration with Team Member A
to ensure commands are correctly received and executed.

3. User and Channel Management
Team Member C could take charge of managing users and channels,
providing state management and data storage for clients.

Responsibilities include:
Implementing user management (storing nicknames, status, etc.).
Managing channel creation, joining, leaving, and broadcasting messages to channel members.
Handling data structures to store client and channel information.

This person should work closely with Team Member B
to ensure commands like JOIN, PART, and PRIVMSG work as intended and maintain consistency.


4. Additional or Overlapping Tasks

Documentation and Testing:
All team members can contribute to writing test scripts
and ensuring each part functions as expected.

Error Handling and Debugging:
Assign time for collaborative debugging and error handling
after individual sections are complete.

Example Workflow:
Phase 1:
Team Member A sets up the server connection,
ensuring it can handle multiple clients.

Phase 2: Team Member B develops the command parser and basic commands like NICK and USER.

Phase 3: Team Member C creates user and channel management,
ensuring JOIN and PRIVMSG work properly.

With regular check-ins,
this approach allows everyone to work on interconnected sections
while maintaining a clear division of labor.

*****
